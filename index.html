<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SCQE Calculator</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: #f4f4f5;
  color: #18181b;
  line-height: 1.5;
  font-size: 14px;
}
.page { max-width: 860px; margin: 0 auto; padding: 2rem 1rem 4rem; }
h1 { font-size: 1.5rem; font-weight: 700; }
.subtitle { color: #52525b; margin-top: 0.4rem; max-width: 640px; }
.ref { font-size: 0.82rem; color: #71717a; margin-top: 0.3rem; }
.ref a { color: #2563eb; text-decoration: none; }
.ref a:hover { text-decoration: underline; }
header { margin-bottom: 1.5rem; }

.card {
  background: white;
  border: 1px solid #e4e4e7;
  border-radius: 8px;
  padding: 1.25rem 1.5rem;
  margin-bottom: 1.25rem;
}
.card-title {
  font-size: 0.72rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: #71717a;
  margin-bottom: 1rem;
}

.tabs { display: flex; gap: 0.5rem; margin-bottom: 1.25rem; }
.tab-btn {
  padding: 0.45rem 1.1rem;
  border: 1px solid #d4d4d8;
  border-radius: 6px;
  background: white;
  cursor: pointer;
  font-size: 0.88rem;
  color: #3f3f46;
  transition: all 0.12s;
}
.tab-btn.active { background: #18181b; color: white; border-color: #18181b; }

label { display: block; font-size: 0.8rem; color: #52525b; margin-bottom: 0.25rem; }
input[type="number"] {
  width: 100%;
  padding: 0.42rem 0.65rem;
  border: 1px solid #d4d4d8;
  border-radius: 5px;
  font-size: 0.9rem;
  color: #18181b;
  background: white;
  -moz-appearance: textfield;
}
input[type="number"]::-webkit-inner-spin-button { opacity: 0.5; }
input[type="number"]:focus { outline: none; border-color: #2563eb; box-shadow: 0 0 0 2px rgba(37,99,235,0.15); }

.g2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
.g3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; }
.g4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 1rem; }
.ig { margin-bottom: 0.75rem; }

.section-lbl {
  font-size: 0.75rem;
  font-weight: 600;
  color: #a1a1aa;
  margin: 1rem 0 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.04em;
}

.cohort-table { width: 100%; border-collapse: collapse; margin-bottom: 0.5rem; }
.cohort-table th, .cohort-table td {
  padding: 0.5rem 0.75rem;
  border: 1px solid #e4e4e7;
}
.cohort-table th {
  background: #fafafa;
  font-size: 0.78rem;
  font-weight: 600;
  color: #52525b;
  text-align: center;
}
.cohort-table th:first-child { text-align: left; }
.cohort-table td { background: white; }
.cohort-table .row-lbl { font-size: 0.85rem; font-weight: 600; color: #3f3f46; white-space: nowrap; }

.btn-compute {
  width: 100%;
  padding: 0.7rem;
  background: #18181b;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  margin-top: 0.75rem;
  transition: background 0.12s;
}
.btn-compute:hover { background: #27272a; }

.chart-wrap { position: relative; height: 360px; }

.interp-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; }
.interp-item {
  padding: 0.85rem 1rem;
  background: #fafafa;
  border-radius: 6px;
  border-left: 3px solid #d4d4d8;
}
.interp-item.less { border-left-color: #2563eb; }
.interp-item.zero { border-left-color: #71717a; }
.interp-item.harm { border-left-color: #dc2626; }
.interp-title { font-size: 0.75rem; font-weight: 600; color: #52525b; margin-bottom: 0.2rem; }
.interp-value { font-size: 1.05rem; font-weight: 700; font-family: ui-monospace, monospace; }
.interp-desc { font-size: 0.75rem; color: #71717a; margin-top: 0.2rem; }

.results-table { width: 100%; border-collapse: collapse; font-size: 0.82rem; font-family: ui-monospace, monospace; }
.results-table th {
  text-align: right; padding: 0.35rem 0.75rem;
  background: #fafafa; border-bottom: 2px solid #e4e4e7;
  font-weight: 600; color: #52525b; font-size: 0.75rem;
  font-family: -apple-system, sans-serif;
}
.results-table th:first-child { text-align: left; }
.results-table td { text-align: right; padding: 0.3rem 0.75rem; border-bottom: 1px solid #f4f4f5; }
.results-table td:first-child { text-align: left; }
.results-table tr:hover td { background: #fafafa; }

.error-msg { color: #dc2626; font-size: 0.85rem; margin-top: 0.5rem; display: none; }

.hidden { display: none !important; }
#results-section { display: none; }

.note { font-size: 0.8rem; color: #71717a; margin-bottom: 0.75rem; }

@media (max-width: 580px) {
  .g3, .g4 { grid-template-columns: 1fr 1fr; }
  .interp-grid { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="page">

<header>
  <h1>Stability-Controlled Quasi-Experiment (SCQE)</h1>
  <p class="subtitle">Enter summary statistics and a range of assumptions on &delta; to compute partial identification bounds on the treatment effect.</p>
  <p class="ref">Hazlett (2019), <em>Estimating causal effects of new treatments despite self-selection.</em> &nbsp;|&nbsp; R package: <a href="https://github.com/chadhazlett/scqe" target="_blank">github.com/chadhazlett/scqe</a></p>
</header>

<div class="tabs">
  <button class="tab-btn active" id="tab-1c" onclick="setMode('1c')">One Cohort</button>
  <button class="tab-btn" id="tab-2c" onclick="setMode('2c')">Two Cohorts</button>
</div>

<div class="card">
  <div class="card-title">Summary Statistics</div>

  <!-- 1-cohort panel -->
  <div id="panel-1c">
    <p class="note">Single cross-section of treated and untreated individuals. The sensitivity parameter &delta; here is a <strong>postulated value for E[Y(0)]</strong> &mdash; the mean potential outcome under no treatment for the treatment-eligible population. Each value of &delta; you enter is a specific assumption about what the average untreated outcome would have been, <em>not</em> a deviation from an observed reference group.</p>
    <div class="g2">
      <div>
        <div class="section-lbl">Untreated group</div>
        <div class="ig"><label>N &mdash; number of individuals</label><input type="number" id="untr" value="100" min="1"></div>
        <div class="ig"><label>&sum;Y &mdash; sum of outcome values</label><input type="number" id="Y_untr" value="5" min="0"></div>
      </div>
      <div>
        <div class="section-lbl">Treated group</div>
        <div class="ig"><label>N &mdash; number of individuals</label><input type="number" id="tr" value="200" min="1"></div>
        <div class="ig"><label>&sum;Y &mdash; sum of outcome values</label><input type="number" id="Y_tr" value="50" min="0"></div>
      </div>
    </div>
  </div>

  <!-- 2-cohort panel -->
  <div id="panel-2c" class="hidden">
    <p class="note">Two time periods (pre/post). Treatment becomes available in the post period. &delta; represents the assumed change in average non-treatment outcome between periods.</p>
    <table class="cohort-table">
      <thead>
        <tr><th></th><th>Pre period (T=0)</th><th>Post period (T=1)</th></tr>
      </thead>
      <tbody>
        <tr>
          <td class="row-lbl">Untreated</td>
          <td>
            <div class="g2">
              <div class="ig"><label>N</label><input type="number" id="untr_pre" value="200" min="0"></div>
              <div class="ig"><label>&sum;Y</label><input type="number" id="Y_untr_pre" value="5" min="0"></div>
            </div>
          </td>
          <td>
            <div class="g2">
              <div class="ig"><label>N</label><input type="number" id="untr_post" value="150" min="0"></div>
              <div class="ig"><label>&sum;Y</label><input type="number" id="Y_untr_post" value="1" min="0"></div>
            </div>
          </td>
        </tr>
        <tr>
          <td class="row-lbl">Treated</td>
          <td>
            <div class="g2">
              <div class="ig"><label>N</label><input type="number" id="tr_pre" value="0" min="0"></div>
              <div class="ig"><label>&sum;Y</label><input type="number" id="Y_tr_pre" value="0" min="0"></div>
            </div>
          </td>
          <td>
            <div class="g2">
              <div class="ig"><label>N</label><input type="number" id="tr_post" value="50" min="0"></div>
              <div class="ig"><label>&sum;Y</label><input type="number" id="Y_tr_post" value="20" min="0"></div>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Delta range (shared) -->
  <div class="section-lbl" id="delta-range-lbl">Postulated E[Y(0)] &mdash; range &amp; options</div>
  <div class="g4">
    <div class="ig"><label id="lbl-min-delta">Min postulated E[Y(0)]</label><input type="number" id="min_delta" value="-0.2" step="0.05"></div>
    <div class="ig"><label id="lbl-max-delta">Max postulated E[Y(0)]</label><input type="number" id="max_delta" value="0.5" step="0.05"></div>
    <div class="ig"><label>Steps</label><input type="number" id="n_steps" value="21" min="3" max="500"></div>
    <div class="ig"><label>Alpha (&alpha;)</label><input type="number" id="alpha" value="0.05" min="0.001" max="0.5" step="0.005"></div>
  </div>

  <div class="error-msg" id="error-msg"></div>
  <button class="btn-compute" onclick="compute()">Compute SCQE</button>
</div>

<!-- Results -->
<div id="results-section">

  <div class="card">
    <div class="card-title" id="chart-card-title">Treatment Effect vs. postulated E[Y(0)]</div>
    <div class="chart-wrap"><canvas id="chart"></canvas></div>
  </div>

  <div class="card">
    <div class="card-title" id="crit-card-title">Critical postulated E[Y(0)] values</div>
    <div class="interp-grid">
      <div class="interp-item less">
        <div class="interp-title">Sig. Negative Effect</div>
        <div class="interp-value" id="crit-less">&mdash;</div>
        <div class="interp-desc" id="crit-less-desc">Must postulate E[Y(0)] &ge; this value to conclude treatment significantly <em>reduces</em> the outcome (upper CI &lt; 0)</div>
      </div>
      <div class="interp-item zero">
        <div class="interp-title">Zero Point Estimate</div>
        <div class="interp-value" id="crit-zero">&mdash;</div>
        <div class="interp-desc" id="crit-zero-desc">Postulated E[Y(0)] at which the point estimate of the treatment effect equals zero</div>
      </div>
      <div class="interp-item harm">
        <div class="interp-title">Sig. Positive Effect</div>
        <div class="interp-value" id="crit-harm">&mdash;</div>
        <div class="interp-desc" id="crit-harm-desc">Must postulate E[Y(0)] &le; this value to conclude treatment significantly <em>increases</em> the outcome (lower CI &gt; 0)</div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">Full Results Table</div>
    <div style="overflow-x:auto">
      <table class="results-table">
        <thead>
          <tr><th id="tbl-delta-hdr">E[Y(0)]</th><th>Estimate</th><th>CI Lower</th><th>CI Upper</th><th>SE</th></tr>
        </thead>
        <tbody id="results-tbody"></tbody>
      </table>
    </div>
  </div>

</div><!-- /results-section -->
</div><!-- /page -->

<script>
// ── Inverse normal CDF (Acklam's rational approximation, max err < 1.15e-9) ──
function qnorm(p) {
  const a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02,
              1.383577518672690e+02, -3.066479806614716e+01,  2.506628277459239e+00];
  const b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02,
              6.680131188771972e+01, -1.328068155288572e+01];
  const c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00,
             -2.549732539343734e+00,  4.374664141464968e+00,  2.938163982698783e+00];
  const d = [7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];
  const plo = 0.02425, phi = 1 - 0.02425;
  let q;
  if (p < plo) {
    q = Math.sqrt(-2 * Math.log(p));
    return (((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) /
           ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
  } else if (p <= phi) {
    q = p - 0.5; const r = q*q;
    return (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q /
           (((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
  } else {
    q = Math.sqrt(-2 * Math.log(1-p));
    return -(((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) /
            ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
  }
}

// ── 1-cohort summary-statistics estimator ────────────────────────────────────
// Inputs: counts/sums for untreated (untr, Y_untr) and treated (tr, Y_tr)
// Follows scqe.1csumm() in the R package
function scqe1c(untr, Y_untr, tr, Y_tr, delta, alpha) {
  const z = qnorm(1 - alpha / 2);
  const N   = tr + untr;
  const pi1 = tr / N;                        // P(treated)
  const Ybar = (Y_tr + Y_untr) / N;          // overall mean outcome

  const estimate = (Ybar - delta) / pi1;
  const se = Math.sqrt(
    (1 / (N - 1)) * (
      (Ybar * (1 - Ybar)) / (pi1 ** 2) +
      ((Ybar - delta) ** 2 * pi1 * (1 - pi1)) / (pi1 ** 4)
    )
  );
  return { estimate, se, conf_low: estimate - z * se, conf_high: estimate + z * se };
}

// ── 2-cohort summary-statistics estimator ────────────────────────────────────
// Follows scqe.2csumm() in the R package
function scqe2c(untr_pre, Y_untr_pre, untr_post, Y_untr_post,
                tr_pre,   Y_tr_pre,   tr_post,   Y_tr_post,   delta, alpha) {
  const z = qnorm(1 - alpha / 2);
  const N_pre = untr_pre + tr_pre,  N_post = untr_post + tr_post;
  const N = N_pre + N_post;
  const Y_pre = Y_tr_pre + Y_untr_pre,  Y_post = Y_tr_post + Y_untr_post;

  // Joint probability terms (all divided by N)
  const P_T1     = N_post / N;
  const P_D1     = (tr_post + tr_pre) / N;
  const P_D1_T1  = tr_post / N;
  const P_D1_T0  = tr_pre  / N;
  const P_D0_T1  = (N_post - tr_post) / N;
  const P_D0_T0  = (N_pre  - tr_pre)  / N;
  const P_T1_D1_Y1 = Y_tr_post  / N,   P_T0_D1_Y1 = Y_tr_pre   / N;
  const P_T1_D0_Y1 = Y_untr_post / N,  P_T0_D0_Y1 = Y_untr_pre / N;
  const P_T1_D1_Y0 = (tr_post  - Y_tr_post)  / N;
  const P_T0_D1_Y0 = (tr_pre   - Y_tr_pre)   / N;
  const P_T1_D0_Y0 = (N_post - tr_post  - Y_untr_post) / N;
  const P_T0_D0_Y0 = (N_pre  - tr_pre   - Y_untr_pre)  / N;

  // SCQE estimate
  const tildeY_post = Y_post / N_post - delta;
  const tildeY_pre  = Y_pre  / N_pre;
  const tr_frac_post = tr_post / N_post,  tr_frac_pre = tr_pre / N_pre;
  const estimate = (tildeY_post - tildeY_pre) / (tr_frac_post - tr_frac_pre);

  const tildeY_all = (Y_pre + Y_post - delta * N_post) / N;
  const Beta_0 = tildeY_all - estimate * P_D1;

  // Variance numerator (sandwich-style)
  const s =
    P_T1_D1_Y1 * (1 - delta - Beta_0 - estimate) ** 2 +
    P_T1_D0_Y1 * (1 - delta - Beta_0)            ** 2 +
    P_T1_D1_Y0 * (   -delta - Beta_0 - estimate) ** 2 +
    P_T1_D0_Y0 * (   -delta - Beta_0)            ** 2 +
    P_T0_D1_Y1 * (1          - Beta_0 - estimate) ** 2 +
    P_T0_D0_Y1 * (1          - Beta_0)            ** 2 +
    P_T0_D1_Y0 * (            -Beta_0 - estimate) ** 2 +
    P_T0_D0_Y0 * (            -Beta_0)            ** 2;

  const var_num = P_T1 * (1 - P_T1) / (N - 2) * s;

  // IV denominator
  const denom =
    P_D1_T1 * (1 - P_D1) * (1 - P_T1) +
    P_D1_T0 * (1 - P_D1) * (  - P_T1) +
    P_D0_T1 * (  - P_D1) * (1 - P_T1) +
    P_D0_T0 * (  - P_D1) * (  - P_T1);

  const se = Math.sqrt(var_num) / denom;
  return { estimate, se, conf_low: estimate - z * se, conf_high: estimate + z * se };
}

// ── Bisection root-finder ─────────────────────────────────────────────────────
function bisect(f, lo, hi, tol = 1e-7, maxIter = 200) {
  let flo = f(lo), fhi = f(hi);
  if (!isFinite(flo) || !isFinite(fhi) || flo * fhi > 0) return null;
  for (let i = 0; i < maxIter; i++) {
    const mid = (lo + hi) / 2, fmid = f(mid);
    if (!isFinite(fmid)) return null;
    if (Math.abs(fmid) < tol || (hi - lo) < tol) return mid;
    flo * fmid <= 0 ? (hi = mid, fhi = fmid) : (lo = mid, flo = fmid);
  }
  return (lo + hi) / 2;
}

// ── Critical delta values ─────────────────────────────────────────────────────
function criticals1c(untr, Y_untr, tr, Y_tr, alpha) {
  const Ybar = (Y_tr + Y_untr) / (tr + untr);
  const run = d => scqe1c(untr, Y_untr, tr, Y_tr, d, alpha);
  return {
    zero_delta: Ybar,                                          // analytic
    less_delta: bisect(d => run(d).conf_high, -10, 10),       // upper CI = 0
    harm_delta: bisect(d => run(d).conf_low,  -10, 10),       // lower CI = 0
  };
}

function criticals2c(up, Yup, upo, Yupo, tp, Ytp, tpo, Ytpo, alpha) {
  const run = d => scqe2c(up, Yup, upo, Yupo, tp, Ytp, tpo, Ytpo, d, alpha);
  return {
    zero_delta: bisect(d => run(d).estimate,  -10, 10),
    less_delta: bisect(d => run(d).conf_high, -10, 10),
    harm_delta: bisect(d => run(d).conf_low,  -10, 10),
  };
}

// ── App state ─────────────────────────────────────────────────────────────────
let mode = '1c', chartInst = null;

function setMode(m) {
  mode = m;
  document.getElementById('panel-1c').classList.toggle('hidden', m !== '1c');
  document.getElementById('panel-2c').classList.toggle('hidden', m !== '2c');
  document.getElementById('tab-1c').classList.toggle('active', m === '1c');
  document.getElementById('tab-2c').classList.toggle('active', m === '2c');

  const is1c = m === '1c';
  // Delta range section labels
  document.getElementById('delta-range-lbl').textContent =
    is1c ? 'Postulated E[Y(0)] \u2014 range & options'
         : '\u03B4 (baseline shift between periods) \u2014 range & options';
  document.getElementById('lbl-min-delta').textContent =
    is1c ? 'Min postulated E[Y(0)]' : 'Min \u03B4';
  document.getElementById('lbl-max-delta').textContent =
    is1c ? 'Max postulated E[Y(0)]' : 'Max \u03B4';
  // Chart & critical-values card titles
  document.getElementById('chart-card-title').textContent =
    is1c ? 'Treatment Effect vs. postulated E[Y(0)]'
         : 'Treatment Effect vs. \u03B4 (baseline shift)';
  document.getElementById('crit-card-title').textContent =
    is1c ? 'Critical postulated E[Y(0)] values'
         : 'Critical \u03B4 values';
  // Results table column header
  document.getElementById('tbl-delta-hdr').textContent =
    is1c ? 'E[Y(0)]' : '\u03B4';
  // Critical value descriptions
  document.getElementById('crit-less-desc').innerHTML =
    is1c ? 'Must postulate E[Y(0)] &ge; this value to conclude treatment significantly <em>reduces</em> the outcome (upper CI &lt; 0)'
         : 'Must assume &delta; &ge; this value to conclude treatment significantly <em>reduces</em> the outcome (upper CI &lt; 0)';
  document.getElementById('crit-zero-desc').innerHTML =
    is1c ? 'Postulated E[Y(0)] at which the point estimate of the treatment effect equals zero'
         : 'Value of &delta; at which the point estimate of the treatment effect equals zero';
  document.getElementById('crit-harm-desc').innerHTML =
    is1c ? 'Must postulate E[Y(0)] &le; this value to conclude treatment significantly <em>increases</em> the outcome (lower CI &gt; 0)'
         : 'Must assume &delta; &le; this value to conclude treatment significantly <em>increases</em> the outcome (lower CI &gt; 0)';
}

function v(id) { return parseFloat(document.getElementById(id).value); }

function showError(msg) {
  const el = document.getElementById('error-msg');
  el.textContent = msg; el.style.display = msg ? 'block' : 'none';
}

function validate1c() {
  const untr = v('untr'), tr = v('tr'), Y_untr = v('Y_untr'), Y_tr = v('Y_tr');
  if (untr < 1 || tr < 1) return 'N must be at least 1 for both groups.';
  if (Y_untr < 0 || Y_tr < 0) return '\u2211Y cannot be negative.';
  if (Y_untr > untr || Y_tr > tr) return '\u2211Y cannot exceed N (for binary outcomes).';
  if (untr + tr < 3) return 'Total N must be at least 3.';
  return null;
}

function validate2c() {
  const up=v('untr_pre'), upo=v('untr_post'), tp=v('tr_pre'), tpo=v('tr_post');
  if (up+upo+tp+tpo < 4) return 'Total N must be at least 4.';
  const N_pre = up+tp, N_post = upo+tpo;
  if (N_pre < 1 || N_post < 1) return 'Both periods must have at least 1 observation.';
  const tp_frac = tp/N_pre, tpo_frac = tpo/N_post;
  if (Math.abs(tp_frac - tpo_frac) < 1e-10)
    return 'Treatment fractions are identical across periods — denominator is zero.';
  return null;
}

function makeDeltas() {
  const lo = v('min_delta'), hi = v('max_delta');
  const n  = Math.max(3, Math.round(v('n_steps')));
  if (lo >= hi) { showError('Min \u03B4 must be less than Max \u03B4.'); return null; }
  const d = [];
  for (let i = 0; i < n; i++) d.push(lo + (hi - lo) * i / (n - 1));
  return d;
}

function compute() {
  showError('');
  const deltas = makeDeltas();
  if (!deltas) return;

  const alpha = v('alpha');
  if (alpha <= 0 || alpha >= 1) { showError('Alpha must be between 0 and 1.'); return; }

  const err = mode === '1c' ? validate1c() : validate2c();
  if (err) { showError(err); return; }

  const results = [];
  for (const d of deltas) {
    let r;
    if (mode === '1c') {
      r = scqe1c(v('untr'), v('Y_untr'), v('tr'), v('Y_tr'), d, alpha);
    } else {
      r = scqe2c(v('untr_pre'), v('Y_untr_pre'), v('untr_post'), v('Y_untr_post'),
                 v('tr_pre'),   v('Y_tr_pre'),   v('tr_post'),   v('Y_tr_post'), d, alpha);
    }
    if (!isFinite(r.estimate) || !isFinite(r.se)) {
      showError(`Computation failed at \u03B4 = ${d.toFixed(4)}. Check inputs.`); return;
    }
    results.push({ delta: d, ...r });
  }

  let crits;
  if (mode === '1c') {
    crits = criticals1c(v('untr'), v('Y_untr'), v('tr'), v('Y_tr'), alpha);
  } else {
    crits = criticals2c(v('untr_pre'), v('Y_untr_pre'), v('untr_post'), v('Y_untr_post'),
                        v('tr_pre'),   v('Y_tr_pre'),   v('tr_post'),   v('Y_tr_post'), alpha);
  }

  const xLabel = mode === '1c'
    ? 'Postulated E[Y(0)]'
    : '\u03B4 (assumed baseline shift between periods)';
  renderChart(results, alpha, xLabel);
  renderTable(results);
  renderCriticals(crits);
  document.getElementById('results-section').style.display = 'block';
  document.getElementById('results-section').scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// ── Rendering ─────────────────────────────────────────────────────────────────
function fmt(x, d = 4) {
  if (x === null || !isFinite(x)) return 'N/A';
  return x.toFixed(d);
}

function renderChart(results, alpha, xLabel) {
  const labels    = results.map(r => r.delta.toFixed(4));
  const estimates = results.map(r => r.estimate);
  const lowerCI   = results.map(r => r.conf_low);
  const upperCI   = results.map(r => r.conf_high);
  const pct       = Math.round((1 - alpha) * 100);

  const ctx = document.getElementById('chart').getContext('2d');
  if (chartInst) chartInst.destroy();

  chartInst = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [
        {
          label: `${pct}% CI Lower`,
          data: lowerCI,
          borderColor: 'rgba(37,99,235,0.35)',
          backgroundColor: 'rgba(37,99,235,0.08)',
          borderWidth: 1.5, borderDash: [5, 3],
          pointRadius: 2, fill: '+1', tension: 0.1,
          order: 2,
        },
        {
          label: `${pct}% CI Upper`,
          data: upperCI,
          borderColor: 'rgba(37,99,235,0.35)',
          backgroundColor: 'rgba(37,99,235,0.08)',
          borderWidth: 1.5, borderDash: [5, 3],
          pointRadius: 2, fill: false, tension: 0.1,
          order: 2,
        },
        {
          label: 'Estimate',
          data: estimates,
          borderColor: 'rgba(37,99,235,1)',
          backgroundColor: 'rgba(37,99,235,1)',
          borderWidth: 2.5, pointRadius: 3,
          fill: false, tension: 0.1,
          order: 1,
        },
      ],
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { position: 'top', labels: { boxWidth: 18, font: { size: 12 } } },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(4)}`,
          },
        },
      },
      scales: {
        x: {
          title: { display: true, text: xLabel, font: { size: 12 } },
          ticks: { maxTicksLimit: 12, font: { size: 11 } },
          grid: { color: '#f0f0f0' },
        },
        y: {
          title: { display: true, text: 'Treatment Effect Estimate (ATTE)', font: { size: 12 } },
          ticks: { font: { size: 11 } },
          grid: { color: '#f0f0f0' },
        },
      },
    },
    plugins: [{
      id: 'zeroline',
      afterDraw(chart) {
        const { ctx, chartArea: ca, scales } = chart;
        if (!scales.y) return;
        const y0 = scales.y.getPixelForValue(0);
        if (y0 < ca.top || y0 > ca.bottom) return;
        ctx.save();
        ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath(); ctx.moveTo(ca.left, y0); ctx.lineTo(ca.right, y0); ctx.stroke();
        ctx.restore();
      },
    }],
  });
}

function renderTable(results) {
  document.getElementById('results-tbody').innerHTML =
    results.map(r => `<tr>
      <td>${fmt(r.delta, 4)}</td>
      <td>${fmt(r.estimate, 4)}</td>
      <td>${fmt(r.conf_low, 4)}</td>
      <td>${fmt(r.conf_high, 4)}</td>
      <td>${fmt(r.se, 4)}</td>
    </tr>`).join('');
}

function renderCriticals(c) {
  const f = x => (x === null || !isFinite(x)) ? 'not found' : x.toFixed(4);
  document.getElementById('crit-less').textContent = f(c.less_delta);
  document.getElementById('crit-zero').textContent = f(c.zero_delta);
  document.getElementById('crit-harm').textContent = f(c.harm_delta);
}

// Run once on load with defaults
window.addEventListener('DOMContentLoaded', compute);
</script>
</body>
</html>
